import {
	Scene, OrthographicCamera, WebGLRenderer, Texture, PlaneGeometry, Mesh,
	MeshBasicMaterial, CanvasTexture, LinearFilter
} from 'three';
import { EffectComposer, RenderPass } from 'postprocessing';

exports.decorateConfig = (config) => {
	return Object.assign({}, config, {
		css: `
		${config.css || ''}

		.term_term {
			position: relative;
		}

		.hyper-postprocessing.canvas {
			position: absolute;
			top: 0;
			left: 0;
		}
		`
	});
};

exports.decorateTerm = (Term, { React }) => {
	class PostProcessing extends React.Component {
		constructor(...args) {
			super(...args);

			this._onDecorated = this._onDecorated.bind(this);
		}

		_onDecorated(term) {
			// this.container = document.querySelector('.term_term');
			// this._setup();

			// requestAnimationFrame(function play() {
			// 	requestAnimationFrame(play.bind(this));

			// 	this.texture.needsUpdate = true;
			// 	this.composer.render();
			// }.bind(this));
		}

		/**
		 * Boilerplate for postprocessing
		 */
		_setup() {
			const containerWidth = this.container.offsetWidth;
			const containerHeight = this.container.offsetHeight;

			this.canvas = document.createElement('canvas');
			this.canvas.classList.add('hyper-postprocessing', 'canvas');

			// steal the canvas generated by XTerm
			this.textureEl = document.querySelector('.xterm .xterm-text-layer');

			// scene!
			this.scene = new Scene();

			// renderer!
			this.renderer = new WebGLRenderer({
				canvas: this.canvas,
				preserveDrawingBuffer: true
			});
			this.renderer.setPixelRatio(window.devicePixelRatio);
			this.renderer.setSize(containerWidth, containerHeight);

			// camera
			this.camera = new OrthographicCamera(
				-containerWidth / 2,
				containerWidth / 2,
				containerHeight / 2,
				-containerHeight / 2,
				1,
				1000
			);
			this.camera.position.z = 1;

			// composer!
			this.composer = new EffectComposer(this.renderer);
			const renderPass = new RenderPass(this.scene, this.camera)
			renderPass.renderToScreen = true;
			this.composer.addPass(renderPass);

			// texture!
			this.texture = new CanvasTexture(this.textureEl);
			this.texture.minFilter = LinearFilter;
			this.texture.magFilter = LinearFilter;

			// mesh!
			const geometry = new PlaneGeometry(containerWidth, containerHeight);
			const material = new MeshBasicMaterial({
				color: 0xFFFFFF,
				map: this.texture
			});
			const mesh = new Mesh(geometry, material);
			this.scene.add(mesh);

			// add the element to the page
			this.container.append(this.renderer.domElement);
		}

		render() {
			return React.createElement(Term, Object.assign({}, this.props, {
				onDecorated: this._onDecorated
			}));
		}
	}

	return PostProcessing;
}
